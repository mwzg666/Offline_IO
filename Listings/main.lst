C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\KeilMDK\C251\BIN\C251.EXE User\main.c XSMALL INTR2 BROWSE INCDIR(.\Ads1110;.\iic;.\IO;.\mcp4725;
                    -.\MwPro;.\uart;.\adc12;.\User) DEBUG PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj) 

stmt  level    source

    1          #include "main.h"
    2          #include <intrins.h>
    3          
    4          #ifdef DEV_FIXED
               #define STATUS_MASK     0x3FFC
               #define MODE_MASK       0x00FC
               #endif
    8          
    9          #ifdef DEV_OFFLINE_LOW
   10          #define STATUS_MASK 0x1FF8      // 能远程控制的IO值1
   11          #define MODE_MASK    0x01F8     // 能闪烁的IO值1
   12          #endif
   13          
   14          WORD  OutStatus = 0;   // 32bit- 0: 关闭  1：打开
   15          WORD  OutMode    = 0;  // 32bit-0: 常亮，1：闪烁
   16          WORD  RunTime    = 0;
   17          WORD  Task1s   = 0;
   18          BOOL  InputReport = FALSE;
   19          BYTE  InputStatus = 0;
   20          BOOL  NeedGetFlow  = TRUE;
   21          BOOL  PaperErr = FALSE;
   22          
   23          BYTE g_Key_Confrom = 0;
   24          
   25          BYTE Input_Status = 0;
   26          
   27          PAGER_CTL xdata Paper;
   28          WORD  PaperPluse = 0;
   29          WORD  PaperTimer = 0;
   30          WORD  CommIdleTime = 0;
   31          BASE_INFO xdata g_BaseInfo;
   32          
   33          static WORD OutHis =  0;
   34          
   35          BYTE  RecvBuf[UART_BUFF_LENGTH] = {0};
   36          BYTE  SendBuf[UART_BUFF_LENGTH] = {0};
   37          BYTE RecLength = 0;
   38          
   39          u16  Timer0Cnt = 0;
   40          
   41          WORD xdata FlashIoTimer[32] = {0};    
   42          
   43          
   44          /*========================================================================
   45          // 函数名称: WORD WordToSmall(WORD dat)
   46          // 函数功能: 将WORD的数据转换为小端模式
   47          // 入口参数: @WORD dat：要转换的数据
   48          // 函数返回: 返回类型为WORD的小端模式数据
   49          // 当前版本: VER1.0
   50          // 修改日期: 2023.5.5
   51          // 当前作者:
   52          // 其他备注: 
   53          ========================================================================*/
   54          WORD WordToSmall(WORD dat)
   55          {
   56   1              BYTE buf[2];
   57   1          BYTE t;
   58   1          WORD ret;
C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 2   

   59   1          
   60   1          memcpy(buf, &dat, 2);
   61   1              t = buf[1];
   62   1              buf[1] = buf[0];
   63   1              buf[0] = t;
   64   1              
   65   1          memcpy(&ret, buf, 2);
   66   1          return ret;
   67   1      }
   68          
   69          float FloatToSmall(float dat)
   70          {
   71   1              BYTE buf[4];
   72   1          BYTE t;
   73   1          float ret;
   74   1          
   75   1          memcpy(buf, &dat, 4);
   76   1              t = buf[3];
   77   1              buf[3] = buf[0];
   78   1              buf[0] = t;
   79   1              t = buf[2];
   80   1              buf[2] = buf[1];
   81   1              buf[1] = t;
   82   1      
   83   1          memcpy(&ret, buf, 4);
   84   1          return ret;
   85   1      }
   86          
   87          DWORD DwordToSmall(DWORD dat)
   88          {
   89   1              BYTE buf[4];
   90   1          BYTE t;
   91   1          DWORD ret;
   92   1          
   93   1          memcpy(buf, &dat, 4);
   94   1              t = buf[3];
   95   1              buf[3] = buf[0];
   96   1              buf[0] = t;
   97   1              t = buf[2];
   98   1              buf[2] = buf[1];
   99   1              buf[1] = t;
  100   1      
  101   1          memcpy(&ret, buf, 4);
  102   1          return ret;
  103   1      }
  104          
  105          void Error()
  106          {
  107   1          while(1)
  108   1          {
  109   2              RUN_LED(1);
  110   2              Delay(50);
  111   2              RUN_LED(0);
  112   2              Delay(50);
  113   2          }
  114   1      }
  115          
  116          //void Delay(WORD ms)
  117          //{
  118          //    WORD t = 1000;
  119          //    while(ms--)
  120          //    {
  121          //        for (t=0;t<1000;t++) ;
  122          //    }
  123          //}
  124          
C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 3   

  125          void Delay(WORD ms)     //@11.0592MHz
  126          {
  127   1          unsigned long edata i;
  128   1      
  129   1          while(ms--)
  130   1          {
  131   2              _nop_();
  132   2              _nop_();
  133   2              i = 2763UL;
  134   2              while (i) 
  135   2              {
  136   3                  i--;
  137   3              }
  138   2          }
  139   1      }
  140          
  141          void SysInit()
  142          {
  143   1          HIRCCR = 0x80;           // 启动内部高速IRC
  144   1          while(!(HIRCCR & 1));
  145   1          CLKSEL = 0;              
  146   1      }
  147          
  148          void Timer0Init()
  149          {
  150   1          AUXR = 0x00;    //Timer0 set as 12T, 16 bits timer auto-reload, 
  151   1          TH0 = (u8)(Timer0_Reload / 256);
  152   1          TL0 = (u8)(Timer0_Reload % 256);
  153   1          ET0 = 1;    //Timer0 interrupt enable
  154   1          TR0 = 1;    //Tiner0 run
  155   1          
  156   1          // 中断优先级3
  157   1      //    PT0  = 1;
  158   1      //    PT0H = 1;
  159   1      }
  160          
  161          // 10ms 中断一下
  162          void Timer0Int (void) interrupt 1
  163          {
  164   1          Timer0Cnt ++;
  165   1      }
  166          
  167          
  168          void Bump_ONOFF(BYTE x)
  169          {
  170   1          VALVE(x);
  171   1          BUMP(x);
  172   1      }
  173          
  174          BYTE Key_Scan(void)
  175          {
  176   1          static BYTE keyVal = 0;
  177   1          if((STOP_M() == 0) || (ALARM_CFM() == 0))
  178   1          {
  179   2              Delay(10);
  180   2              if(STOP_M() == 0)
  181   2              {
  182   3                  keyVal = STOP_OK;
  183   3              }
  184   2              if(ALARM_CFM() == 0)
  185   2              {
  186   3                  keyVal = ALARMCFM_OK;
  187   3              }
  188   2          }
  189   1          else
  190   1          {
C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 4   

  191   2              keyVal = 0;
  192   2          }
  193   1          return keyVal;
  194   1      }
  195          
  196          void Output(BYTE i, BYTE x)
  197          {
  198   1          switch(i)
  199   1          {
  200   2              
  201   2              case BIT_HOST_POWER:    HOST_POWER(x);    break;    // 主电源控制
  202   2              case BIT_SYS_POWER:     SYS_POWER(x);     break;    // 工控机电源控制
  203   2              case BIT_SEN_ONOFF:     SEN_POWER(x);     break;    // 探测器电源  
  204   2              case BIT_LED_RED:       LED_RED(x);       break;    // 指示灯(红)
  205   2              case BIT_LED_YELLOW:    LED_YELLOW(x);    break;    // 指示灯(黄)
  206   2              case BIT_LED_GREEN:     LED_GREEN(x);     break;    // 指示灯(绿)
  207   2              case BIT_LIGHT_RED:     LIGHT_RED(x);     break;    // 报警灯（红）
  208   2              case BIT_LIGHT_YELLOW:  LIGHT_YELLOW(x); break;     // 报警灯（黄）
  209   2              case BIT_ALARM_SOUND:   ALARM_SOUND(x);   break;    // 报警声控制
  210   2              case BIT_BUMP:          Bump_ONOFF(x);    break;    // 泵
  211   2              case BIT_PREA:          PREA(x);          break;    // 预警
  212   2              case BIT_ALARM:         ALARM(x);         break;    // 报警
  213   2              #ifdef DEV_FIXED
                       case BIT_CHU_SHUAN:     CHU_SHUAN(x);     break;    // 除酸
                       case BIT_CHOU_QI:       CHOU_QI(x);       break;    // 抽气
                       case BIT_ZHOU_ZHI:      ZHOU_ZHI(x);      break;    // 走纸
                       #endif
  218   2              case BIT_FAULT:         FAULT(x);         break;    // 故障
  219   2          }
  220   1      }
  221          
  222          
  223          // 闪烁 -- 300ms 开 300ms 关
  224          void OutFlash(BYTE i)
  225          {
  226   1          //static BYTE FlashHis = 0;
  227   1          WORD mask = 0;
  228   1          
  229   1          if (FlashIoTimer[i]++ > 20)   // 320ms
  230   1          {
  231   2              FlashIoTimer[i] = 0;
  232   2              
  233   2              mask = 1<<i;
  234   2              if ((OutHis & mask) == 0)
  235   2              {
  236   3                  OutHis |= mask;
  237   3                  Output(i, 1);
  238   3              }
  239   2              else
  240   2              {
  241   3                  OutHis &= ~mask;
  242   3                  Output(i, 0);
  243   3              }
  244   2          }
  245   1      }
  246          
  247          void OutVal(BYTE i, BYTE st)
  248          {
  249   1          WORD mask = 1 << i;
  250   1          WORD his = (WORD)((OutHis >> i) & 1);
  251   1          if (his == st)
  252   1          {
  253   2              return;
  254   2          }
  255   1      
  256   1          if (st)
C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 5   

  257   1          {
  258   2              OutHis |= mask;
  259   2          }
  260   1          else
  261   1          {
  262   2              OutHis &= ~mask;
  263   2          }
  264   1          
  265   1          Output(i, st);
  266   1      }
  267          
  268          // Io输出控制 -- 16ms 运行一次
  269          void OutTask()
  270          {
  271   1          BYTE i, st;
  272   1          WORD mask;
  273   1          for (i=0;i<16;i++)
  274   1          {
  275   2              mask = 1 << i;
  276   2              if ((mask & STATUS_MASK) == 0)
  277   2              {
  278   3                  // 有些IO不能在这里控制
  279   3                  continue;
  280   3              }
  281   2              
  282   2              if ( (OutMode & (1 << i) ) != 0)    // 闪烁模式
  283   2              {
  284   3                  if ((OutStatus & (1 << i)) != 0)
  285   3                  {
  286   4                      // 开始闪烁
  287   4                      OutFlash(i);
  288   4                  }
  289   3                  else
  290   3                  {
  291   4                      // 停止闪烁
  292   4                      OutVal(i, 0);
  293   4                  }
  294   3              }
  295   2              else
  296   2              {
  297   3                  st = (OutStatus & (1 << i))?1:0;
  298   3                  OutVal(i, st);
  299   3              }
  300   2          }
  301   1      }
  302          
  303          
  304          void Task_1s()
  305          {
  306   1          #if 0
                   static BYTE on = 1;
                   OutCtl(on,   BIT_ALARM_1);
                   on = !on;
                   #endif
  311   1         
  312   1          //Read4_20ma();
  313   1          //GetFlow();
  314   1      
  315   1          int Voltage = 0;
  316   1          CLR_WDT = 1;  // 喂狗
  317   1      
  318   1          // 需要的是否才采集
  319   1          if (NeedGetFlow)
  320   1          {
  321   2              NeedGetFlow = FALSE;
  322   2              //GetAds1110(I2C_GASFLOW1); 
C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 6   

  323   2              g_BaseInfo.Flow1 = Voltage;
  324   2      
  325   2              //GetAds1110(I2C_GASFLOW2); 
  326   2              g_BaseInfo.Flow2 = Voltage;
  327   2      
  328   2              //GetAds1110(I2C_PROGRESS); 
  329   2              g_BaseInfo.Press = Voltage;
  330   2              g_BaseInfo.Temp = Voltage;
  331   2          }
  332   1      }
  333          
  334          
  335          void RunLed(WORD dt)
  336          {
  337   1          static WORD tm = 0;
  338   1          tm += dt;
  339   1          if (tm > 2500)
  340   1          {
  341   2              tm = 0;
  342   2              RUN_LED(0);
  343   2          }
  344   1          else if (tm > 2300)
  345   1          {
  346   2              RUN_LED(1);
  347   2          }
  348   1              
  349   1      }
  350          
  351          
  352          // 定时任务
  353          void TimerTask(void)
  354          {
  355   1          WORD Delta = 0;
  356   1      
  357   1          if (Timer0Cnt)
  358   1          {
  359   2              Delta = Timer0Cnt * 10;
  360   2              Timer0Cnt = 0;
  361   2      
  362   2              if (RX1_Cnt > 0)
  363   2              {
  364   3                  Rx1_Timer += Delta;
  365   3              }
  366   2      
  367   2              if (RunTime < 5000)
  368   2              {
  369   3                  RunTime += Delta;
  370   3              }
  371   2              #ifdef DEV_FIXED
                       if (Paper.OnOff)
                       {
                           PaperTimer += Delta;
                       }
                       #endif
  377   2              Task1s += Delta;
  378   2              if (Task1s >= 1000)
  379   2              {
  380   3                  Task1s = 0;
  381   3                  if (InputReport == FALSE)
  382   3                  {
  383   4                      Task_1s();
  384   4                  }
  385   3              }
  386   2      
  387   2              if (CommIdleTime < 500)
  388   2              {
C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 7   

  389   3                  CommIdleTime += Delta;
  390   3              } 
  391   2              
  392   2              OutTask();
  393   2              RunLed(Delta);
  394   2          }
  395   1      }
  396          
  397          void OutCtl(BYTE st, BYTE i)
  398          {
  399   1          switch(st)
  400   1          {
  401   2              case 0: OutStatus &= ~(1<<i); OutMode &= ~(1<<i);  break;
  402   2              case 1: OutStatus |= (1<<i);   OutMode &= ~(1<<i);   break;
  403   2              case 2: OutStatus |= (1<<i);   OutMode |= (1<<i);    break;
  404   2      
  405   2              // 报警声特殊操作 -- 沿用原来的协议
  406   2              case 0xAA: OutStatus |= (1<<i);   OutMode |= (1<<i);    break;   // 开启
  407   2              case 0x55: OutStatus &= ~(1<<i); OutMode &= ~(1<<i);  break;  // 关闭
  408   2          }
  409   1      }
  410          
  411          
  412          void LampCtl()
  413          {
  414   1          LED_PARAM led;
  415   1          memcpy(&led, (BYTE *)&RecvBuf[sizeof(FRAME_HEAD)], sizeof(LED_PARAM));
  416   1      
  417   1          OutCtl(led.StateLed_Green,   BIT_LED_GREEN);
  418   1          OutCtl(led.StateLed_Red,     BIT_LED_RED);
  419   1          OutCtl(led.StateLed_Yellow, BIT_LED_YELLOW);
  420   1          OutCtl(led.AlarmLed_RED ,    BIT_LIGHT_RED);
  421   1          OutCtl(led.AlarmLed_Yellow, BIT_LIGHT_YELLOW);
  422   1           
  423   1          OutStatus &= STATUS_MASK;
  424   1          OutMode &= MODE_MASK;
  425   1      }
  426          
  427          void SndCtl()
  428          {
  429   1          BYTE Snd = RecvBuf[sizeof(FRAME_HEAD)];
  430   1          OutCtl(Snd, BIT_ALARM_SOUND);
  431   1           
  432   1          OutStatus &= STATUS_MASK;
  433   1          OutMode &= MODE_MASK;
  434   1      }
  435          
  436          void IoCtl()
  437          {
  438   1          OUT_PARAM out;
  439   1          memcpy(&out, (BYTE *)&RecvBuf[sizeof(FRAME_HEAD)], sizeof(OUT_PARAM));
  440   1          #ifdef DEV_OFFLINE_LOW
  441   1          OutCtl(out.Prea,      BIT_PREA);
  442   1          OutCtl(out.Alarm,     BIT_ALARM);
  443   1          OutCtl(out.Fault,     BIT_FAULT);
  444   1          OutCtl(out.Bump,      BIT_BUMP);
  445   1          #endif
  446   1          
  447   1          #ifdef DEV_FIXED
                   OutCtl(out.Alarm1,     BIT_ALARM_1);
                   OutCtl(out.Alarm2,     BIT_ALARM_2);
                   OutCtl(out.Alarm3,     BIT_ALARM_3);
                   OutCtl(out.ChuShuan,   BIT_CHU_SHUAN);
                   OutCtl(out.ChouQi ,    BIT_CHOU_QI);
                   #endif
  454   1          
C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 8   

  455   1          OutStatus &= STATUS_MASK;
  456   1          OutMode &= MODE_MASK;
  457   1      }
  458          
  459          void LedInit()
  460          {
  461   1         // 初始状态都为0 
  462   1         //运行灯
  463   1         RUN_LED(0);          // 运行灯
  464   1         // 指示灯
  465   1         LED_RED(0);          // 指示灯（红）
  466   1         LED_YELLOW(0) ;      // 指示灯（黄）
  467   1         LED_GREEN(0);        // 指示灯（绿）
  468   1         //报警灯
  469   1         LIGHT_RED(0) ;       // 报警灯（红）
  470   1         LIGHT_YELLOW(0);     // 报警灯（黄）
  471   1         ALARM_SOUND(0);      // 报警音 
  472   1         //报警
  473   1         PREA(0);
  474   1         ALARM(0);
  475   1         FAULT(0);
  476   1         Bump_ONOFF(0);
  477   1      
  478   1      
  479   1      }
  480          
  481          void GetFlow()
  482          {
  483   1          BASE_INFO baseinfo;
  484   1          NeedGetFlow = TRUE;
  485   1          baseinfo.Flow1 = WordToSmall(g_BaseInfo.Flow1);
  486   1          baseinfo.Flow2 = WordToSmall(g_BaseInfo.Flow2);
  487   1          baseinfo.Press = WordToSmall(g_BaseInfo.Press);
  488   1          baseinfo.Temp  = WordToSmall(g_BaseInfo.Temp);
  489   1          
  490   1          SendCmd(CMD_GET_FLOW,(BYTE *)&baseinfo,sizeof(BASE_INFO));
  491   1      }
  492          
  493          #ifdef DEV_FIXED
               void CtlPaper()
               {
                   memcpy(&Paper, (BYTE *)&RecvBuf[sizeof(FRAME_HEAD)], sizeof(PAGER_CTL));
                   if (Paper.OnOff)
                   {
                       OutCtl(1,    BIT_ZHOU_ZHI);
                       PaperTimer = 0;
                       PaperPluse = 0;
                   }
                   else
                   {
                       OutCtl(0,    BIT_ZHOU_ZHI);
                   }
               }
               #endif
  509          
  510          void Out4_20ma(BYTE val)
  511          {
  512   1          WORD v = (WORD)((float)val * 88.5);
  513   1          v = WordToSmall(v);
  514   1          MCP4725_OutVol(MCP4725_BL_ADDR, v);
  515   1      }
  516          
  517          
  518          void Out4_20ma_2(BYTE val)
  519          {
  520   1          WORD v = (WORD)((float)val * 88.5);
C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 9   

  521   1          v = WordToSmall(v);
  522   1          MCP4725_OutVol2(MCP4725_BL_ADDR, v);
  523   1      }
  524          
  525          
  526          
  527          BYTE Read4_20ma()
  528          {
  529   1          BYTE ret = 0;
  530   1          int Voltage = 0;
  531   1          GetAds1110(I2C_4_20MA_IN);
  532   1      
  533   1          ret = (BYTE)((float)Voltage/60);
  534   1          SendCmd(CMD_GET_4_20MA, &ret, 1);
  535   1          return ret;
  536   1      }
  537          
  538          
  539          void GetVer()
  540          {
  541   1          BYTE ver[8] = {0};
  542   1          memcpy(ver, VERSION, strlen(VERSION));
  543   1          SendCmd(CMD_VER, ver, 8);
  544   1      }
  545          
  546          
  547          void HndUartFrame()
  548          {
  549   1          FRAME_HEAD *pFrameHead = (FRAME_HEAD *)RecvBuf; 
  550   1          switch(pFrameHead->Cmd)
  551   1          {
  552   2              case CMD_LED_CTL:  LampCtl();  break;    // 报警灯控制
  553   2              case CMD_SOUND:    SndCtl();   break;    // 报警音
  554   2              case CMD_IO_OUT:   IoCtl();    break;          
  555   2              case CMD_VER:      GetVer();   break;    // 软件版本
  556   2      
  557   2              case CMD_GET_FLOW:    GetFlow();    break;
  558   2              #ifdef DEV_FIXED
                       case CMD_CTL_PAPER:   CtlPaper();   break;
                       #endif
  561   2              case CMD_OUT_4_20MA:  Out4_20ma(RecvBuf[sizeof(FRAME_HEAD)]);    break;
  562   2              case CMD_GET_4_20MA:  Read4_20ma();  break;
  563   2              case CMD_OUT_4_20MA_2:Out4_20ma_2(RecvBuf[sizeof(FRAME_HEAD)]);    break;
  564   2          }
  565   1      }
  566          
  567          void PowerOff()
  568          {
  569   1          RUN_LED(0);
  570   1          HOST_POWER(0);
  571   1          SYS_POWER(0);
  572   1          SEN_POWER(0);
  573   1          
  574   1          while(1)
  575   1          {
  576   2              ;
  577   2          }
  578   1      }
  579          
  580          void PowerHnd(BYTE InVal)
  581          {
  582   1          IN_DEF in;
  583   1          in.Val = InVal;
  584   1      
  585   1          if (RunTime >= 5000)  // 关机
  586   1          {
C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 10  

  587   2              if (in.IoBit.HostPwSt == 0)  // 工控已经关机
  588   2              {
  589   3                  OutVal(BIT_HOST_POWER, OFF);   // 关闭总电源
  590   3                  OutVal(BIT_SEN_ONOFF, OFF);   // IO板总电源
  591   3                  OutVal(BIT_SYS_POWER, OFF);   // 关闭工控机
  592   3      
  593   3                  PowerOff();
  594   3              }
  595   2          }
  596   1      }
  597          
  598          
  599          
  600          BYTE GetInput()
  601          {
  602   1          // 当前只有一个开关机状态 P5.0  
  603   1          BYTE ret;
  604   1          
  605   1      
  606   1          ret = P1 & 0x0B;
  607   1          ret <<= 4;
  608   1          ret |= (P4 & 0x02);
  609   1          ret |= (P5 & 0x01);
  610   1          return ret;
  611   1      }
  612          
  613          
  614          
  615          void HndInput()
  616          {
  617   1          #define IO_MASK 0x33  
  618   1      
  619   1          static BYTE InHis = 0;
  620   1          static BYTE RpHis = 0;
  621   1          
  622   1          BYTE InCur = GetInput();
  623   1          PowerHnd(InCur);
  624   1          
  625   1          if (InHis != InCur)
  626   1          {
  627   2              Delay(20);
  628   2              InCur = GetInput();
  629   2              if (InCur != InHis)
  630   2              {
  631   3                  InHis = InCur;
  632   3      
  633   3                  InCur &= IO_MASK;
  634   3                  if (RpHis != InCur)
  635   3                  {
  636   4                      // 状态变了才上报
  637   4                      RpHis = InCur;
  638   4                      InputReport = TRUE;
  639   4                      InputStatus = InCur;
  640   4                      //SendCmd(CMD_IO_IN, (BYTE *)&InCur, 1);
  641   4                      //Sleep(10);
  642   4                  }
  643   3              }
  644   2          }
  645   1      }
  646          
  647          void ReportInput()
  648          {
  649   1          BYTE ret = 1;
  650   1          
  651   1          // 通信空闲的时候才上报，不然会冲突
  652   1          if (CommIdleTime > 200)
C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 11  

  653   1          {
  654   2              if (InputReport)
  655   2              {
  656   3                  InputReport = FALSE;
  657   3                  SendCmd(CMD_IO_IN, (BYTE *)&InputStatus, 1);
  658   3                  return;
  659   3              }
  660   2          }
  661   1      }
  662          
  663          
  664          
  665          void ClearRevBuf()
  666          {
  667   1          memset(RecvBuf, 0, UART_BUFF_LENGTH);
  668   1          RecLength = 0;
  669   1      }
  670          
  671          void HndUartData()
  672          {
  673   1          if (ValidUartFrame())
  674   1          {
  675   2              HndUartFrame();
  676   2          }
  677   1          ClearRevBuf();
  678   1      }
  679          
  680          int main( void )
  681          {
  682   1          SysInit();
  683   1          
  684   1          IoInit();
  685   1          OutVal(BIT_HOST_POWER, ON);      //主电源
  686   1          
  687   1          LedInit(); 
  688   1          RUN_LED(1);
  689   1          
  690   1          OutVal(BIT_SEN_ONOFF, ON);      // 上电打开IO板总电源
  691   1          OutVal(BIT_SYS_POWER, ON);      // 上电打开工控机
  692   1      
  693   1          Delay(200);
  694   1          
  695   1          Timer0Init();
  696   1          UART1_config();
  697   1          ClearUart1Buf();
  698   1      
  699   1          Delay(200);
  700   1          Out4_20ma(0);
  701   1          
  702   1          OutCtl(1, BIT_LED_GREEN);   // 上电开启运行灯
  703   1          
  704   1          RUN_LED(0);
  705   1          
  706   1          EA = 1;
  707   1      
  708   1          WDT_CONTR |= (1<<5) |  7;  // 启动开门狗，约8秒
  709   1          while(1)
  710   1          {         
  711   2              TimerTask();
  712   2              HndInput();
  713   2              Uart1Hnd();
  714   2              ReportInput();
  715   2              
  716   2          }  
  717   1      }
  718          
C251 COMPILER V5.60.0,  main                                                               22/03/24  16:09:26  PAGE 12  

  719          
  720          
  721          
  722          
  723          
  724          
  725          
  726          
  727          
  728          
  729          
  730          
  731          
  732          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2895     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       203     ------
  xdata-const size     =    ------     ------
  edata size           =       158         61
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       461     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
